@page "/upload"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Linq
@using System.Collections.Generic
@using System.Text.Json.Serialization
@inject IJSRuntime JS
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery
@inject Microsoft.AspNetCore.Http.IHttpContextAccessor HttpContextAccessor

<h3>Import CNAB File</h3>

<input type="file" @ref="fileInput" accept=".txt,text/plain" />
<button class="btn btn-primary" @onclick="UploadAsync" disabled="@isUploading">Import</button>

@if (isUploading)
{
    <p><em>Importing...</em></p>
}

@if (resultMessage is not null)
{
    <div class="alert alert-info mt-3">@resultMessage</div>
}

<h4>Stores</h4>

@if (stores == null)
{
    <p><em>Loading...</em></p>
}
else if (!stores.Any())
{
    <p><em>No stores available.</em></p>
}
else
{
    foreach (var s in PagedStores)
    {
        <div class="card mb-2">
            <div class="card-body">
                <h5>@s.Name - Balance: @( (s.Transactions?.Sum(t => t.Amount) ?? 0m).ToString("C") )</h5>
                <p>Owner: @s.Owner</p>
                <table class="table">
                    <thead><tr><th>Date</th><th>Type</th><th>CPF</th><th>Card</th></tr></thead>
                    <tbody>
                        @foreach (var t in s.Transactions ?? Enumerable.Empty<TransactionsStoreResponse>())
                        {
                            <tr>
                                <td>@t.Date</td>
                                <td>@t.TypeDescription</td>
                                <td>@t.Cpf</td>
                                <td>@t.Card</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </div>
    }

    <nav aria-label="Stores pagination" class="mt-3">
        <div class="d-flex align-items-center justify-content-between">
            <div>
                <button class="btn btn-outline-secondary me-2" @onclick="PrevPage" disabled="@(CurrentPage == 1)">Previous</button>
                <button class="btn btn-outline-secondary" @onclick="NextPage" disabled="@(CurrentPage >= TotalPages)">Next</button>
            </div>

            <div>
                Page @CurrentPage of @TotalPages
            </div>

            <div class="d-flex align-items-center">
                <label class="me-2 mb-0">Page size</label>
                <select class="form-select" style="width: auto;" @onchange="OnPageSizeChanged">
                    @foreach (var size in PageSizeOptions)
                    {
                        <option value="@size" selected="@(size == PageSize)">@size</option>
                    }
                </select>
            </div>
        </div>

        <div class="mt-2">
            @foreach (var p in Enumerable.Range(1, TotalPages))
            {
                <button class="btn btn-sm @(p == CurrentPage ? "btn-primary" : "btn-outline-primary") me-1" @onclick="() => GoToPage(p)">@p</button>
            }
        </div>
    </nav>
}

@code {
    private ElementReference fileInput;
    private bool isUploading;
    private string? resultMessage;
    private IList<StoreResponse>? stores;

    // Pagination state
    private int CurrentPage { get; set; } = 1;
    private int PageSize { get; set; } = 5;
    private readonly int[] PageSizeOptions = new[] { 5, 10, 20 };

    private IEnumerable<StoreResponse> PagedStores
        => stores?.Skip((CurrentPage - 1) * PageSize).Take(PageSize) ?? Enumerable.Empty<StoreResponse>();

    private int TotalItems => stores?.Count ?? 0;
    private int TotalPages => Math.Max(1, (int)Math.Ceiling(TotalItems / (double)PageSize));

    private async Task UploadAsync()
    {
        resultMessage = null;

        try
        {
            isUploading = true;

            string? token = null;
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext is not null)
            {
                var tokens = Antiforgery.GetAndStoreTokens(httpContext);
                token = tokens.RequestToken;
            }
            var result = await JS.InvokeAsync<UploadResult>("uploadFile", fileInput, token);

            if (!result.Success)
            {
                resultMessage = $"Failed: {result.Status} - {result.Body}";
                return;
            }

            if (result.Summary is not null)
            {
                resultMessage = $"Lines: {result.Summary.TotalLines}, Imported: {result.Summary.ImportedTransactions}, ParseErrors: {result.Summary.ParseErrors}";
            }
            else
            {
                resultMessage = "Import completed (no summary returned).";
            }

            await LoadStores();
        }
        catch (JSException jsex)
        {
            resultMessage = $"Upload failed: {jsex.Message}";
        }
        catch (Exception ex)
        {
            resultMessage = $"Unexpected error: {ex.Message}";
        }
        finally
        {
            isUploading = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadStores();
            StateHasChanged();
        }
    }

    private async Task LoadStores()
    {
        var json = await JS.InvokeAsync<string>("getStores");
        if (string.IsNullOrWhiteSpace(json))
        {
            stores = Array.Empty<StoreResponse>();
            return;
        }

        var options = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };

        try
        {
            var parsed = JsonSerializer.Deserialize<IList<StoreResponse>>(json, options);
            stores = parsed ?? Array.Empty<StoreResponse>();
            CurrentPage = Math.Min(CurrentPage, TotalPages);
        }
        catch (JsonException)
        {
            stores = Array.Empty<StoreResponse>();
        }
    }

    private void PrevPage()
    {
        if (CurrentPage > 1)
        {
            CurrentPage--;
        }
    }

    private void NextPage()
    {
        if (CurrentPage < TotalPages)
        {
            CurrentPage++;
        }
    }

    private void GoToPage(int page)
    {
        if (page >= 1 && page <= TotalPages)
        {
            CurrentPage = page;
        }
    }

    private async Task OnPageSizeChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var newSize) && newSize > 0)
        {
            PageSize = newSize;
            CurrentPage = 1;
            await InvokeAsync(StateHasChanged);
        }
    }

    public class StoreResponse
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Owner { get; set; } = string.Empty;
        public IEnumerable<TransactionsStoreResponse> Transactions { get; set; } = Array.Empty<TransactionsStoreResponse>();
    }

    public class TransactionsStoreResponse
    {
        public int Id { get; set; }
        public string TypeDescription { get; set; } = string.Empty;
        public DateTime Date { get; set; }
        public decimal Amount { get; set; }
        public string Cpf { get; set; } = string.Empty;
        public string Card { get; set; } = string.Empty;
    }

    record DomFile(string Name);

    private sealed class UploadResult
    {
        public bool Success { get; set; }
        public int Status { get; set; }
        public string? Body { get; set; }
        public ImportSummary? Summary { get; set; }
    }

    private sealed class ImportSummary
    {
        public int TotalLines { get; set; }
        public int ImportedTransactions { get; set; }
        public int ParseErrors { get; set; }
    }
}

